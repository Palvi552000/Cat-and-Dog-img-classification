# -*- coding: utf-8 -*-
"""image classification cat and dog final project 2 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tT3fXb8RZUDxTs7XeWylx0mqJ5WgrvtA

# **Get Dataset**
"""

!pip install -q kaggle

!mkdir -p ~/.kaggle

!cp /content/kaggle.json ~/.kaggle/

!chmod 600 ~/.kaggle/kaggle.json

"""# Load and Preprocess the Dataset"""

!kaggle datasets download -d tongpython/cat-and-dog

!mkdir cat-and-dog
!mv cat-and-dog.zip cat-and-dog

# Commented out IPython magic to ensure Python compatibility.
# %cd cat-and-dog/

!unzip cat-and-dog.zip

"""# **Import Libraries and Data**"""

#libraries
import numpy as np
import pandas as pd
import os
import random
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.image import imread
from PIL import Image
import warnings
warnings.filterwarnings('ignore')

from sklearn.metrics import classification_report, confusion_matrix, f1_score
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import Dense,MaxPooling2D,Dropout,Flatten,BatchNormalization,Conv2D
from tensorflow.keras.callbacks import ReduceLROnPlateau,EarlyStopping

# Display img
import cv2
from google.colab.patches import cv2_imshow
img= cv2.imread('/content/cat-and-dog/test_set/test_set/cats/cat.4028.jpg')
cv2_imshow(img)

import matplotlib.pyplot as plt
import cv2
import os

# Images Directory
input_dir = '/content/cat-and-dog/test_set/test_set/cats'
output_dir = '/content/cat-and-dog/test_set/test_set/dogs'

# Read all images from the directory
images = [cv2.imread(os.path.join(input_dir, file)) for file in os.listdir(input_dir) if file.endswith(('.jpg', '.jpeg', '.png'))]

# Number of images
num_images = len(images)

# Define the figure size and layout
fig = plt.figure(figsize=(299, 299))
rows = 10
cols = 10

# Display images
for i in range(1, num_images + 1):
    fig.add_subplot(rows, cols, 1)
    plt.imshow(cv2.cvtColor(images[i-1], cv2.COLOR_BGR2RGB))
    plt.axis('off')

plt.show()

"""# **Load Image Data**"""

train_datagen = ImageDataGenerator(
   rescale=1./299,
    rotation_range=15,
    horizontal_flip=True,
    zoom_range=0.2,
    shear_range=0.1,
    fill_mode='reflect',
    width_shift_range=0.1,
    height_shift_range=0.1,
    validation_split=0.2
)

test_datagen = ImageDataGenerator(rescale=1./299)

train_generator = train_datagen.flow_from_directory(
    'training_set',
    target_size=(299, 299),
    batch_size=32,
    class_mode='binary',
    subset='training'
)

val_generator = train_datagen.flow_from_directory(
    'training_set',
    target_size=(299, 299),
    batch_size=32,
    class_mode='binary',
    subset='validation'
)

test_generator = test_datagen.flow_from_directory(
    'test_set',
    target_size=(299,299),
    batch_size=32,
    class_mode='binary'
)

import matplotlib.pyplot as plt
import os
from tensorflow.keras.preprocessing.image import load_img

# Set the paths to your image folders
cat_folder = 'training_set/training_set/cats'
dog_folder = 'training_set/training_set/dogs'

# Function to display images
def display_images(folder, title, n_images=10):
    images = os.listdir(folder)[:n_images]
    plt.figure(figsize=(10, 10))
    for i, img_name in enumerate(images):
        img = load_img(os.path.join(folder, img_name), target_size=(299, 299))
        plt.subplot(1, 10, i + 1)
        plt.imshow(img)
        plt.title(f"{title} {i+1}")
        plt.axis('off')
    plt.show()

# Display 10 cat images
display_images(cat_folder, "Cat")

# Display 10 dog images
display_images(dog_folder, "Dog")

"""# **Modling**"""

model = Sequential()

model.add(Conv2D(filters = 32,kernel_size = (3,3),padding='same',activation='relu', input_shape = (299,299,3)))
model.add(MaxPooling2D(pool_size=(2,2) ,strides=2 , padding='same'))

model.add(Conv2D(filters = 64,kernel_size = (3,3),padding='same',activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2) ,strides=2 , padding='same'))

model.add(Conv2D(filters = 128,kernel_size = (3,3),padding='same',activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2) ,strides=2 , padding='same'))

model.add(Flatten())

model.add(Dense(128 , activation = 'relu'))
model.add(Dense(64 , activation = 'relu'))
model.add(Dense(32 , activation = 'relu'))

model.add(Dense(1 , activation = 'sigmoid'))
model.summary()

ES = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
RL = ReduceLROnPlateau(monitor='val_loss', factor=0.2, patience=2, min_lr=1e-6)
model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'])
history = model.fit(train_generator,epochs = 2, validation_data = val_generator, callbacks=[ES,RL],)

plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Model accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper left')

# Plot training & validation loss values
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper left')

plt.tight_layout()
plt.show()

"""# **Prediction**"""

y_pred_prob = model.predict(test_generator, steps=test_generator.samples // test_generator.batch_size + 1)
y_pred = (y_pred_prob > 0.5).astype(int)  # For binary classification

# Get true labels
y_test = test_generator.classes

# Calculate F1 score
f1 = f1_score(y_test, y_pred, average='weighted')  # Use 'weighted' for multi-class classification
print(f'F1 Score = {f1:.2f}')

# Print classification report
print(f'Classification Report:\n{classification_report(y_test, y_pred)}')

# Plot confusion matrix
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', cmap='Greens')
plt.show()

filenames = test_generator.filenames

# Number of images to display
num_images_to_display = 10

# Create a subplot grid
fig, axes = plt.subplots(1, num_images_to_display, figsize=(20, 10))

# Display images with predictions
for i in range(num_images_to_display):
    image_path = os.path.join('test_set', filenames[i])
    image = plt.imread(image_path)

    axes[i].imshow(image)
    predicted_label = 'Dog' if y_pred[i] == 1 else 'Cat'
    axes[i].set_title(f"Pred: {predicted_label}")
    axes[i].axis('off')

plt.tight_layout()
plt.show()